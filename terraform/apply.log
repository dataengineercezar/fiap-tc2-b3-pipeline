[0m[1mmodule.s3.aws_s3_bucket.data_lake: Refreshing state... [id=pos-tech-b3-pipeline-cezar-2026][0m
[0m[1mmodule.s3.aws_s3_bucket_versioning.data_lake: Refreshing state... [id=pos-tech-b3-pipeline-cezar-2026][0m
[0m[1mmodule.s3.aws_s3_bucket_server_side_encryption_configuration.data_lake: Refreshing state... [id=pos-tech-b3-pipeline-cezar-2026][0m
[0m[1mmodule.s3.aws_s3_bucket_notification.data_lake_events: Refreshing state... [id=pos-tech-b3-pipeline-cezar-2026][0m
[0m[1mmodule.s3.aws_s3_bucket_public_access_block.data_lake: Refreshing state... [id=pos-tech-b3-pipeline-cezar-2026][0m
[0m[1mmodule.s3.aws_s3_bucket_lifecycle_configuration.data_lake: Refreshing state... [id=pos-tech-b3-pipeline-cezar-2026][0m

Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  [32m+[0m create[0m

Terraform will perform the following actions:

[1m  # module.eventbridge.aws_cloudwatch_event_rule.scraping_schedule[0m will be created
[0m  [32m+[0m[0m resource "aws_cloudwatch_event_rule" "scraping_schedule" {
      [32m+[0m[0m arn                 = (known after apply)
      [32m+[0m[0m description         = "Aciona Lambda de scraping diariamente apÃ³s fechamento B3"
      [32m+[0m[0m event_bus_name      = "default"
      [32m+[0m[0m force_destroy       = false
      [32m+[0m[0m id                  = (known after apply)
      [32m+[0m[0m name                = "b3-pipeline-scraping-schedule-dev"
      [32m+[0m[0m name_prefix         = (known after apply)
      [32m+[0m[0m schedule_expression = "cron(0 22 ? * MON-FRI *)"
      [32m+[0m[0m tags                = {
          [32m+[0m[0m "Component"   = "EventBridge"
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Name"        = "b3-pipeline-scraping-schedule-dev"
          [32m+[0m[0m "Project"     = "b3-pipeline"
          [32m+[0m[0m "Purpose"     = "AutomatedScraping"
        }
      [32m+[0m[0m tags_all            = {
          [32m+[0m[0m "Component"   = "EventBridge"
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Name"        = "b3-pipeline-scraping-schedule-dev"
          [32m+[0m[0m "Project"     = "b3-pipeline"
          [32m+[0m[0m "Purpose"     = "AutomatedScraping"
        }
    }

[1m  # module.eventbridge.aws_cloudwatch_event_target.lambda_scraping[0m will be created
[0m  [32m+[0m[0m resource "aws_cloudwatch_event_target" "lambda_scraping" {
      [32m+[0m[0m arn            = (known after apply)
      [32m+[0m[0m event_bus_name = "default"
      [32m+[0m[0m force_destroy  = false
      [32m+[0m[0m id             = (known after apply)
      [32m+[0m[0m input          = jsonencode(
            {
              [32m+[0m[0m source    = "eventbridge-schedule"
              [32m+[0m[0m timestamp = "$$.time"
            }
        )
      [32m+[0m[0m rule           = "b3-pipeline-scraping-schedule-dev"
      [32m+[0m[0m target_id      = "LambdaScraping"
    }

[1m  # module.eventbridge.aws_lambda_permission.allow_eventbridge[0m will be created
[0m  [32m+[0m[0m resource "aws_lambda_permission" "allow_eventbridge" {
      [32m+[0m[0m action              = "lambda:InvokeFunction"
      [32m+[0m[0m function_name       = "b3-pipeline-scraping-dev"
      [32m+[0m[0m id                  = (known after apply)
      [32m+[0m[0m principal           = "events.amazonaws.com"
      [32m+[0m[0m source_arn          = (known after apply)
      [32m+[0m[0m statement_id        = "AllowExecutionFromEventBridge"
      [32m+[0m[0m statement_id_prefix = (known after apply)
    }

[1m  # module.iam.aws_iam_role.lambda_scraping[0m will be created
[0m  [32m+[0m[0m resource "aws_iam_role" "lambda_scraping" {
      [32m+[0m[0m arn                   = (known after apply)
      [32m+[0m[0m assume_role_policy    = jsonencode(
            {
              [32m+[0m[0m Statement = [
                  [32m+[0m[0m {
                      [32m+[0m[0m Action    = "sts:AssumeRole"
                      [32m+[0m[0m Effect    = "Allow"
                      [32m+[0m[0m Principal = {
                          [32m+[0m[0m Service = "lambda.amazonaws.com"
                        }
                    },
                ]
              [32m+[0m[0m Version   = "2012-10-17"
            }
        )
      [32m+[0m[0m create_date           = (known after apply)
      [32m+[0m[0m force_detach_policies = false
      [32m+[0m[0m id                    = (known after apply)
      [32m+[0m[0m managed_policy_arns   = (known after apply)
      [32m+[0m[0m max_session_duration  = 3600
      [32m+[0m[0m name                  = "b3-pipeline-lambda-scraping-dev"
      [32m+[0m[0m name_prefix           = (known after apply)
      [32m+[0m[0m path                  = "/"
      [32m+[0m[0m tags                  = {
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Name"        = "b3-pipeline-lambda-scraping-role"
          [32m+[0m[0m "Project"     = "b3-pipeline"
        }
      [32m+[0m[0m tags_all              = {
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Name"        = "b3-pipeline-lambda-scraping-role"
          [32m+[0m[0m "Project"     = "b3-pipeline"
        }
      [32m+[0m[0m unique_id             = (known after apply)

      [32m+[0m[0m inline_policy (known after apply)
    }

[1m  # module.iam.aws_iam_role.lambda_trigger_glue[0m will be created
[0m  [32m+[0m[0m resource "aws_iam_role" "lambda_trigger_glue" {
      [32m+[0m[0m arn                   = (known after apply)
      [32m+[0m[0m assume_role_policy    = jsonencode(
            {
              [32m+[0m[0m Statement = [
                  [32m+[0m[0m {
                      [32m+[0m[0m Action    = "sts:AssumeRole"
                      [32m+[0m[0m Effect    = "Allow"
                      [32m+[0m[0m Principal = {
                          [32m+[0m[0m Service = "lambda.amazonaws.com"
                        }
                    },
                ]
              [32m+[0m[0m Version   = "2012-10-17"
            }
        )
      [32m+[0m[0m create_date           = (known after apply)
      [32m+[0m[0m force_detach_policies = false
      [32m+[0m[0m id                    = (known after apply)
      [32m+[0m[0m managed_policy_arns   = (known after apply)
      [32m+[0m[0m max_session_duration  = 3600
      [32m+[0m[0m name                  = "b3-pipeline-lambda-trigger-glue-dev"
      [32m+[0m[0m name_prefix           = (known after apply)
      [32m+[0m[0m path                  = "/"
      [32m+[0m[0m tags                  = {
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Name"        = "b3-pipeline-lambda-trigger-role"
          [32m+[0m[0m "Project"     = "b3-pipeline"
        }
      [32m+[0m[0m tags_all              = {
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Name"        = "b3-pipeline-lambda-trigger-role"
          [32m+[0m[0m "Project"     = "b3-pipeline"
        }
      [32m+[0m[0m unique_id             = (known after apply)

      [32m+[0m[0m inline_policy (known after apply)
    }

[1m  # module.iam.aws_iam_role_policy.lambda_s3_access[0m will be created
[0m  [32m+[0m[0m resource "aws_iam_role_policy" "lambda_s3_access" {
      [32m+[0m[0m id          = (known after apply)
      [32m+[0m[0m name        = "lambda-s3-access"
      [32m+[0m[0m name_prefix = (known after apply)
      [32m+[0m[0m policy      = jsonencode(
            {
              [32m+[0m[0m Statement = [
                  [32m+[0m[0m {
                      [32m+[0m[0m Action   = [
                          [32m+[0m[0m "s3:PutObject",
                          [32m+[0m[0m "s3:PutObjectAcl",
                          [32m+[0m[0m "s3:GetObject",
                          [32m+[0m[0m "s3:ListBucket",
                        ]
                      [32m+[0m[0m Effect   = "Allow"
                      [32m+[0m[0m Resource = [
                          [32m+[0m[0m "arn:aws:s3:::pos-tech-b3-pipeline-cezar-2026",
                          [32m+[0m[0m "arn:aws:s3:::pos-tech-b3-pipeline-cezar-2026/*",
                        ]
                    },
                ]
              [32m+[0m[0m Version   = "2012-10-17"
            }
        )
      [32m+[0m[0m role        = (known after apply)
    }

[1m  # module.iam.aws_iam_role_policy.lambda_start_glue[0m will be created
[0m  [32m+[0m[0m resource "aws_iam_role_policy" "lambda_start_glue" {
      [32m+[0m[0m id          = (known after apply)
      [32m+[0m[0m name        = "lambda-start-glue"
      [32m+[0m[0m name_prefix = (known after apply)
      [32m+[0m[0m policy      = jsonencode(
            {
              [32m+[0m[0m Statement = [
                  [32m+[0m[0m {
                      [32m+[0m[0m Action   = [
                          [32m+[0m[0m "glue:StartJobRun",
                          [32m+[0m[0m "glue:GetJobRun",
                          [32m+[0m[0m "glue:GetJobRuns",
                        ]
                      [32m+[0m[0m Effect   = "Allow"
                      [32m+[0m[0m Resource = "*"
                    },
                ]
              [32m+[0m[0m Version   = "2012-10-17"
            }
        )
      [32m+[0m[0m role        = (known after apply)
    }

[1m  # module.iam.aws_iam_role_policy_attachment.lambda_logs[0m will be created
[0m  [32m+[0m[0m resource "aws_iam_role_policy_attachment" "lambda_logs" {
      [32m+[0m[0m id         = (known after apply)
      [32m+[0m[0m policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
      [32m+[0m[0m role       = "b3-pipeline-lambda-scraping-dev"
    }

[1m  # module.iam.aws_iam_role_policy_attachment.lambda_trigger_logs[0m will be created
[0m  [32m+[0m[0m resource "aws_iam_role_policy_attachment" "lambda_trigger_logs" {
      [32m+[0m[0m id         = (known after apply)
      [32m+[0m[0m policy_arn = "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
      [32m+[0m[0m role       = "b3-pipeline-lambda-trigger-glue-dev"
    }

[1m  # module.lambda.aws_cloudwatch_log_group.scraping[0m will be created
[0m  [32m+[0m[0m resource "aws_cloudwatch_log_group" "scraping" {
      [32m+[0m[0m arn               = (known after apply)
      [32m+[0m[0m id                = (known after apply)
      [32m+[0m[0m log_group_class   = (known after apply)
      [32m+[0m[0m name              = "/aws/lambda/b3-pipeline-scraping-dev"
      [32m+[0m[0m name_prefix       = (known after apply)
      [32m+[0m[0m retention_in_days = 7
      [32m+[0m[0m skip_destroy      = false
      [32m+[0m[0m tags              = {
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Project"     = "b3-pipeline"
        }
      [32m+[0m[0m tags_all          = {
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Project"     = "b3-pipeline"
        }
    }

[1m  # module.lambda.aws_cloudwatch_log_group.trigger_glue[0m will be created
[0m  [32m+[0m[0m resource "aws_cloudwatch_log_group" "trigger_glue" {
      [32m+[0m[0m arn               = (known after apply)
      [32m+[0m[0m id                = (known after apply)
      [32m+[0m[0m log_group_class   = (known after apply)
      [32m+[0m[0m name              = "/aws/lambda/b3-pipeline-trigger-glue-dev"
      [32m+[0m[0m name_prefix       = (known after apply)
      [32m+[0m[0m retention_in_days = 7
      [32m+[0m[0m skip_destroy      = false
      [32m+[0m[0m tags              = {
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Project"     = "b3-pipeline"
        }
      [32m+[0m[0m tags_all          = {
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Project"     = "b3-pipeline"
        }
    }

[1m  # module.lambda.aws_lambda_function.scraping[0m will be created
[0m  [32m+[0m[0m resource "aws_lambda_function" "scraping" {
      [32m+[0m[0m architectures                  = (known after apply)
      [32m+[0m[0m arn                            = (known after apply)
      [32m+[0m[0m code_sha256                    = (known after apply)
      [32m+[0m[0m filename                       = "./../build/lambda_scraping.zip"
      [32m+[0m[0m function_name                  = "b3-pipeline-scraping-dev"
      [32m+[0m[0m handler                        = "lambda_scraping.lambda_handler"
      [32m+[0m[0m id                             = (known after apply)
      [32m+[0m[0m invoke_arn                     = (known after apply)
      [32m+[0m[0m last_modified                  = (known after apply)
      [32m+[0m[0m memory_size                    = 512
      [32m+[0m[0m package_type                   = "Zip"
      [32m+[0m[0m publish                        = false
      [32m+[0m[0m qualified_arn                  = (known after apply)
      [32m+[0m[0m qualified_invoke_arn           = (known after apply)
      [32m+[0m[0m reserved_concurrent_executions = -1
      [32m+[0m[0m role                           = (known after apply)
      [32m+[0m[0m runtime                        = "python3.12"
      [32m+[0m[0m signing_job_arn                = (known after apply)
      [32m+[0m[0m signing_profile_version_arn    = (known after apply)
      [32m+[0m[0m skip_destroy                   = false
      [32m+[0m[0m source_code_hash               = "JBb4t81rcDP1lJYN9Igx9Ezj8ebRAFqZXI3c71KT5IQ="
      [32m+[0m[0m source_code_size               = (known after apply)
      [32m+[0m[0m tags                           = {
          [32m+[0m[0m "Component"   = "Lambda"
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "Function"    = "DataIngestion"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Name"        = "b3-pipeline-lambda-scraping-dev"
          [32m+[0m[0m "Project"     = "b3-pipeline"
        }
      [32m+[0m[0m tags_all                       = {
          [32m+[0m[0m "Component"   = "Lambda"
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "Function"    = "DataIngestion"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Name"        = "b3-pipeline-lambda-scraping-dev"
          [32m+[0m[0m "Project"     = "b3-pipeline"
        }
      [32m+[0m[0m timeout                        = 300
      [32m+[0m[0m version                        = (known after apply)

      [32m+[0m[0m environment {
          [32m+[0m[0m variables = {
              [32m+[0m[0m "DATASET"   = "petr4"
              [32m+[0m[0m "DAYS"      = "5"
              [32m+[0m[0m "S3_BUCKET" = "pos-tech-b3-pipeline-cezar-2026"
              [32m+[0m[0m "S3_PREFIX" = "raw"
              [32m+[0m[0m "TICKER"    = "petr4"
            }
        }

      [32m+[0m[0m ephemeral_storage (known after apply)

      [32m+[0m[0m logging_config (known after apply)

      [32m+[0m[0m tracing_config (known after apply)
    }

[1m  # module.lambda.aws_lambda_function.trigger_glue[0m will be created
[0m  [32m+[0m[0m resource "aws_lambda_function" "trigger_glue" {
      [32m+[0m[0m architectures                  = (known after apply)
      [32m+[0m[0m arn                            = (known after apply)
      [32m+[0m[0m code_sha256                    = (known after apply)
      [32m+[0m[0m filename                       = "./../build/lambda_trigger_glue.zip"
      [32m+[0m[0m function_name                  = "b3-pipeline-trigger-glue-dev"
      [32m+[0m[0m handler                        = "lambda_trigger_glue.lambda_handler"
      [32m+[0m[0m id                             = (known after apply)
      [32m+[0m[0m invoke_arn                     = (known after apply)
      [32m+[0m[0m last_modified                  = (known after apply)
      [32m+[0m[0m memory_size                    = 256
      [32m+[0m[0m package_type                   = "Zip"
      [32m+[0m[0m publish                        = false
      [32m+[0m[0m qualified_arn                  = (known after apply)
      [32m+[0m[0m qualified_invoke_arn           = (known after apply)
      [32m+[0m[0m reserved_concurrent_executions = -1
      [32m+[0m[0m role                           = (known after apply)
      [32m+[0m[0m runtime                        = "python3.12"
      [32m+[0m[0m signing_job_arn                = (known after apply)
      [32m+[0m[0m signing_profile_version_arn    = (known after apply)
      [32m+[0m[0m skip_destroy                   = false
      [32m+[0m[0m source_code_hash               = "UPNMY262qmuuse2ckC52U94DiHQUu0IWsNYmPV3Ebj4="
      [32m+[0m[0m source_code_size               = (known after apply)
      [32m+[0m[0m tags                           = {
          [32m+[0m[0m "Component"   = "Lambda"
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "Function"    = "GlueTrigger"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Name"        = "b3-pipeline-lambda-trigger-glue-dev"
          [32m+[0m[0m "Project"     = "b3-pipeline"
        }
      [32m+[0m[0m tags_all                       = {
          [32m+[0m[0m "Component"   = "Lambda"
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "Function"    = "GlueTrigger"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Name"        = "b3-pipeline-lambda-trigger-glue-dev"
          [32m+[0m[0m "Project"     = "b3-pipeline"
        }
      [32m+[0m[0m timeout                        = 60
      [32m+[0m[0m version                        = (known after apply)

      [32m+[0m[0m environment {
          [32m+[0m[0m variables = {
              [32m+[0m[0m "GLUE_JOB_NAME" = "b3-pipeline-etl-dev"
            }
        }

      [32m+[0m[0m ephemeral_storage (known after apply)

      [32m+[0m[0m logging_config (known after apply)

      [32m+[0m[0m tracing_config (known after apply)
    }

[1m  # module.lambda.aws_lambda_permission.allow_s3[0m will be created
[0m  [32m+[0m[0m resource "aws_lambda_permission" "allow_s3" {
      [32m+[0m[0m action              = "lambda:InvokeFunction"
      [32m+[0m[0m function_name       = "b3-pipeline-trigger-glue-dev"
      [32m+[0m[0m id                  = (known after apply)
      [32m+[0m[0m principal           = "s3.amazonaws.com"
      [32m+[0m[0m source_arn          = "arn:aws:s3:::pos-tech-b3-pipeline-cezar-2026"
      [32m+[0m[0m statement_id        = "AllowExecutionFromS3"
      [32m+[0m[0m statement_id_prefix = (known after apply)
    }

[1mPlan:[0m 14 to add, 0 to change, 0 to destroy.
[0m
Changes to Outputs:
  [32m+[0m[0m eventbridge_schedule_expression   = "cron(0 22 ? * MON-FRI *)"
  [32m+[0m[0m eventbridge_schedule_rule_name    = "b3-pipeline-scraping-schedule-dev"
  [32m+[0m[0m lambda_scraping_function_arn      = (known after apply)
  [32m+[0m[0m lambda_scraping_function_name     = "b3-pipeline-scraping-dev"
  [32m+[0m[0m lambda_scraping_role_arn          = (known after apply)
  [32m+[0m[0m lambda_trigger_glue_function_name = "b3-pipeline-trigger-glue-dev"
  [32m+[0m[0m lambda_trigger_glue_role_arn      = (known after apply)
[0m[1mmodule.iam.aws_iam_role.lambda_scraping: Creating...[0m[0m
[0m[1mmodule.iam.aws_iam_role.lambda_trigger_glue: Creating...[0m[0m
[31mâ•·[0m[0m
[31mâ”‚[0m [0m[1m[31mError: [0m[0m[1mcreating IAM Role (b3-pipeline-lambda-scraping-dev): operation error IAM: CreateRole, https response error StatusCode: 403, RequestID: 91b9fe99-1d33-43de-9782-43c48034ee03, api error AccessDenied: User: arn:aws:iam::732592767587:user/cezar-cli is not authorized to perform: iam:CreateRole on resource: arn:aws:iam::732592767587:role/b3-pipeline-lambda-scraping-dev because no identity-based policy allows the iam:CreateRole action[0m
[31mâ”‚[0m [0m
[31mâ”‚[0m [0m[0m  with module.iam.aws_iam_role.lambda_scraping,
[31mâ”‚[0m [0m  on modules/iam/main.tf line 4, in resource "aws_iam_role" "lambda_scraping":
[31mâ”‚[0m [0m   4: resource "aws_iam_role" "lambda_scraping" [4m{[0m[0m
[31mâ”‚[0m [0m
[31mâ•µ[0m[0m
[31mâ•·[0m[0m
[31mâ”‚[0m [0m[1m[31mError: [0m[0m[1mcreating IAM Role (b3-pipeline-lambda-trigger-glue-dev): operation error IAM: CreateRole, https response error StatusCode: 403, RequestID: a216da5f-d3f2-46c1-ae1c-82e4f112435f, api error AccessDenied: User: arn:aws:iam::732592767587:user/cezar-cli is not authorized to perform: iam:CreateRole on resource: arn:aws:iam::732592767587:role/b3-pipeline-lambda-trigger-glue-dev because no identity-based policy allows the iam:CreateRole action[0m
[31mâ”‚[0m [0m
[31mâ”‚[0m [0m[0m  with module.iam.aws_iam_role.lambda_trigger_glue,
[31mâ”‚[0m [0m  on modules/iam/main.tf line 60, in resource "aws_iam_role" "lambda_trigger_glue":
[31mâ”‚[0m [0m  60: resource "aws_iam_role" "lambda_trigger_glue" [4m{[0m[0m
[31mâ”‚[0m [0m
[31mâ•µ[0m[0m
[0m[1mmodule.iam.aws_iam_role.lambda_trigger_glue: Refreshing state... [id=b3-pipeline-lambda-trigger-glue-dev][0m
[0m[1mmodule.iam.aws_iam_role.lambda_scraping: Refreshing state... [id=b3-pipeline-lambda-scraping-dev][0m
[0m[1mmodule.s3.aws_s3_bucket.data_lake: Refreshing state... [id=pos-tech-b3-pipeline-cezar-2026][0m
[0m[1mmodule.s3.aws_s3_bucket_public_access_block.data_lake: Refreshing state... [id=pos-tech-b3-pipeline-cezar-2026][0m
[0m[1mmodule.s3.aws_s3_bucket_versioning.data_lake: Refreshing state... [id=pos-tech-b3-pipeline-cezar-2026][0m
[0m[1mmodule.s3.aws_s3_bucket_notification.data_lake_events: Refreshing state... [id=pos-tech-b3-pipeline-cezar-2026][0m
[0m[1mmodule.s3.aws_s3_bucket_server_side_encryption_configuration.data_lake: Refreshing state... [id=pos-tech-b3-pipeline-cezar-2026][0m
[0m[1mmodule.s3.aws_s3_bucket_lifecycle_configuration.data_lake: Refreshing state... [id=pos-tech-b3-pipeline-cezar-2026][0m
[0m[1mmodule.iam.aws_iam_role_policy_attachment.lambda_trigger_logs: Refreshing state... [id=b3-pipeline-lambda-trigger-glue-dev-20260118194429774300000001][0m
[0m[1mmodule.iam.aws_iam_role_policy.lambda_start_glue: Refreshing state... [id=b3-pipeline-lambda-trigger-glue-dev:lambda-start-glue][0m
[0m[1mmodule.iam.aws_iam_role_policy.lambda_s3_access: Refreshing state... [id=b3-pipeline-lambda-scraping-dev:lambda-s3-access][0m
[0m[1mmodule.iam.aws_iam_role_policy_attachment.lambda_logs: Refreshing state... [id=b3-pipeline-lambda-scraping-dev-20260118194429803200000002][0m
[0m[1mmodule.lambda.aws_lambda_function.trigger_glue: Refreshing state... [id=b3-pipeline-trigger-glue-dev][0m
[0m[1mmodule.lambda.aws_lambda_function.scraping: Refreshing state... [id=b3-pipeline-scraping-dev][0m
[0m[1mmodule.lambda.aws_lambda_permission.allow_s3: Refreshing state... [id=AllowExecutionFromS3][0m

Terraform used the selected providers to generate the following execution
plan. Resource actions are indicated with the following symbols:
  [32m+[0m create[0m

Terraform will perform the following actions:

[1m  # module.eventbridge.aws_cloudwatch_event_rule.scraping_schedule[0m will be created
[0m  [32m+[0m[0m resource "aws_cloudwatch_event_rule" "scraping_schedule" {
      [32m+[0m[0m arn                 = (known after apply)
      [32m+[0m[0m description         = "Aciona Lambda de scraping diariamente apÃ³s fechamento B3"
      [32m+[0m[0m event_bus_name      = "default"
      [32m+[0m[0m force_destroy       = false
      [32m+[0m[0m id                  = (known after apply)
      [32m+[0m[0m name                = "b3-pipeline-scraping-schedule-dev"
      [32m+[0m[0m name_prefix         = (known after apply)
      [32m+[0m[0m schedule_expression = "cron(0 22 ? * MON-FRI *)"
      [32m+[0m[0m tags                = {
          [32m+[0m[0m "Component"   = "EventBridge"
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Name"        = "b3-pipeline-scraping-schedule-dev"
          [32m+[0m[0m "Project"     = "b3-pipeline"
          [32m+[0m[0m "Purpose"     = "AutomatedScraping"
        }
      [32m+[0m[0m tags_all            = {
          [32m+[0m[0m "Component"   = "EventBridge"
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Name"        = "b3-pipeline-scraping-schedule-dev"
          [32m+[0m[0m "Project"     = "b3-pipeline"
          [32m+[0m[0m "Purpose"     = "AutomatedScraping"
        }
    }

[1m  # module.eventbridge.aws_cloudwatch_event_target.lambda_scraping[0m will be created
[0m  [32m+[0m[0m resource "aws_cloudwatch_event_target" "lambda_scraping" {
      [32m+[0m[0m arn            = "arn:aws:lambda:sa-east-1:732592767587:function:b3-pipeline-scraping-dev"
      [32m+[0m[0m event_bus_name = "default"
      [32m+[0m[0m force_destroy  = false
      [32m+[0m[0m id             = (known after apply)
      [32m+[0m[0m input          = jsonencode(
            {
              [32m+[0m[0m source    = "eventbridge-schedule"
              [32m+[0m[0m timestamp = "$$.time"
            }
        )
      [32m+[0m[0m rule           = "b3-pipeline-scraping-schedule-dev"
      [32m+[0m[0m target_id      = "LambdaScraping"
    }

[1m  # module.eventbridge.aws_lambda_permission.allow_eventbridge[0m will be created
[0m  [32m+[0m[0m resource "aws_lambda_permission" "allow_eventbridge" {
      [32m+[0m[0m action              = "lambda:InvokeFunction"
      [32m+[0m[0m function_name       = "b3-pipeline-scraping-dev"
      [32m+[0m[0m id                  = (known after apply)
      [32m+[0m[0m principal           = "events.amazonaws.com"
      [32m+[0m[0m source_arn          = (known after apply)
      [32m+[0m[0m statement_id        = "AllowExecutionFromEventBridge"
      [32m+[0m[0m statement_id_prefix = (known after apply)
    }

[1m  # module.lambda.aws_cloudwatch_log_group.scraping[0m will be created
[0m  [32m+[0m[0m resource "aws_cloudwatch_log_group" "scraping" {
      [32m+[0m[0m arn               = (known after apply)
      [32m+[0m[0m id                = (known after apply)
      [32m+[0m[0m log_group_class   = (known after apply)
      [32m+[0m[0m name              = "/aws/lambda/b3-pipeline-scraping-dev"
      [32m+[0m[0m name_prefix       = (known after apply)
      [32m+[0m[0m retention_in_days = 7
      [32m+[0m[0m skip_destroy      = false
      [32m+[0m[0m tags              = {
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Project"     = "b3-pipeline"
        }
      [32m+[0m[0m tags_all          = {
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Project"     = "b3-pipeline"
        }
    }

[1m  # module.lambda.aws_cloudwatch_log_group.trigger_glue[0m will be created
[0m  [32m+[0m[0m resource "aws_cloudwatch_log_group" "trigger_glue" {
      [32m+[0m[0m arn               = (known after apply)
      [32m+[0m[0m id                = (known after apply)
      [32m+[0m[0m log_group_class   = (known after apply)
      [32m+[0m[0m name              = "/aws/lambda/b3-pipeline-trigger-glue-dev"
      [32m+[0m[0m name_prefix       = (known after apply)
      [32m+[0m[0m retention_in_days = 7
      [32m+[0m[0m skip_destroy      = false
      [32m+[0m[0m tags              = {
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Project"     = "b3-pipeline"
        }
      [32m+[0m[0m tags_all          = {
          [32m+[0m[0m "Dataset"     = "petr4"
          [32m+[0m[0m "Environment" = "dev"
          [32m+[0m[0m "ManagedBy"   = "Terraform"
          [32m+[0m[0m "Project"     = "b3-pipeline"
        }
    }

[1mPlan:[0m 5 to add, 0 to change, 0 to destroy.
[0m[0m[1mmodule.lambda.aws_cloudwatch_log_group.scraping: Creating...[0m[0m
[0m[1mmodule.lambda.aws_cloudwatch_log_group.trigger_glue: Creating...[0m[0m
[0m[1mmodule.lambda.aws_cloudwatch_log_group.scraping: Creation complete after 1s [id=/aws/lambda/b3-pipeline-scraping-dev][0m
[0m[1mmodule.lambda.aws_cloudwatch_log_group.trigger_glue: Creation complete after 1s [id=/aws/lambda/b3-pipeline-trigger-glue-dev][0m
[0m[1mmodule.eventbridge.aws_cloudwatch_event_rule.scraping_schedule: Creating...[0m[0m
[31mâ•·[0m[0m
[31mâ”‚[0m [0m[1m[31mError: [0m[0m[1mcreating EventBridge Rule (b3-pipeline-scraping-schedule-dev): operation error EventBridge: PutRule, https response error StatusCode: 400, RequestID: 957714a2-718a-400c-9b9b-fdd8072d28b3, api error AccessDeniedException: User: arn:aws:iam::732592767587:user/cezar-cli is not authorized to perform: events:TagResource on resource: arn:aws:events:sa-east-1:732592767587:rule/b3-pipeline-scraping-schedule-dev because no identity-based policy allows the events:TagResource action[0m
[31mâ”‚[0m [0m
[31mâ”‚[0m [0m[0m  with module.eventbridge.aws_cloudwatch_event_rule.scraping_schedule,
[31mâ”‚[0m [0m  on modules/eventbridge/main.tf line 5, in resource "aws_cloudwatch_event_rule" "scraping_schedule":
[31mâ”‚[0m [0m   5: resource "aws_cloudwatch_event_rule" "scraping_schedule" [4m{[0m[0m
[31mâ”‚[0m [0m
[31mâ•µ[0m[0m
